<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">var hooks= require('hooks'),
	Base = require('../NGN.core');
	
<span id='NGN-model-Model'>/**
</span> * @class NGN.model.Model
 * A base model class for creating logical application classes, such as entities, actors, or business logic.
 * 
 * @private
 * @extends NGN
 * @author Corey Butler
 * @requires hooks
 */
var Class = Base.extend({
	
<span id='NGN-model-Model-method-constructor'>	/**
</span>	 * @constructor
	 * Create a new NGN.model. This can be done by passing a configuration object. If using persistence, the object
	 * can be automatically fetched by ID reference. For example:
	 * 		var person = new NGN.model.Person('id123');
	 * This will attempt to use the default persistence datasource to read data for the id `id123`.
	 */
	constructor: function(config){
		
		config = config || {};
		
		if (typeof config !== 'object') {
			config = {
				id: config
			};
		}
	
		Class.super.constructor.call(this,config);
		
		var me = this;
		
		Object.defineProperties(this,{
			
<span id='NGN-model-Model-cfg-type'>			/**
</span>			 * @cfg {String} [type=Model]
			 * The type of NGN.model.
			 * @readonly
			 * @protected
			 */
			type: {
				value:		config.type || 'Model',
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-cfg-idAttribute'>			/**
</span>			 * @cfg {String} [idAttribute='id']
			 * Setting this allows an attribute of the object to be used as the ID.
			 * For example, if an email is the ID of a user, this would be set to
			 * `email`.
			 */
			idAttribute: {
				value:		config.idAttribute || 'id',
				enumerable:	false,
				writable:	false
			},
			
<span id='NGN-model-Model-property-fields'>			/**
</span>			 * @property {Object}
			 * A private object containing the data fields of the model, including
			 * validators &amp; default values. 
			 * @private
			 */
			fields: {
				value:		config.fields || {
								id: {
									required: 	true,
									type:		String,
									'default':	config.id || null
								}
							},
				enumerable:	false,
				writable:	true,
				configurable:true
			},
			
<span id='NGN-model-Model-property-virtuals'>			/**
</span>			 * @property {Object}
			 * A private object containing virtual data attributes and generated data.
			 * @private 
			 */
			virtuals: {
				value:		config.virtuals || {},
				enumerable:	false,
				writable:	true,
				configurable:true
			},
			
<span id='NGN-model-Model-property-isNew'>			/**
</span>			 * @property {Boolean}
			 * Indicates the model is new or does not exist according to the persistence store.
			 * @private
			 */
			isNew: {
				value:		true,
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-property-oid'>			/**
</span>			 * @property {String} [oid=null]
			 * The raw object ID, which is either the #id or #idAttribute depending
			 * on how the object is configured.
			 * @private
			 * @hidden
			 */
			oid: {
				value:		config[this.idAttribute] || null,
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-cfg-id'>			/**
</span>			 * @cfg {String/Number/Date} [id=null]
			 * The unique ID of the model object.
			 */
<span id='NGN-model-Model-property-id'>			/**
</span>			 * @property {String/Number/Date} [id=null]
			 * The unique ID of the model object. If #idAttribute is defined,
			 * this will get/set the #idAttribute value.
			 */
			id: {
				enumerable:	true,
				get:		function(){
								return this.oid;
							},
				set:		function(value){
								this[this.idAttribute] = value;
								this.oid = value;
							}
			},
			
<span id='NGN-model-Model-cfg-allowInvalidSave'>			/**
</span>			 * @cfg {Boolean} [allowInvalidSave=false]
			 * Set this to true to allow a save even though not all of the data properties 
			 * pass validation tests.
			 */
			allowInvalidSave: {
				value:		__NGN.coalesce(config.allowInvalidSave,false),
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-property-modified'>			/**
</span>             * @property {Boolean}
             * Indicates one or more data properties has changed.
             * @readonly
             */
            modified: {
                value:		false,
                enumerable: true,
                writable:	true
            },
            
<span id='NGN-model-Model-property-validators'>            /**
</span>             * @property {Object}
             * The validation rules used to verify data integrity when persisting to a datasource.
             * @private
             */
            validators: {
				value:		{},
				enumerable:	false,
				writable:	false		
			},
			
<span id='NGN-model-Model-cfg-disableDataValidation'>			/**
</span>			 * @cfg {Boolean} [disableDataValidation=false]
			 * Only used when #save is called. Setting this to `true` will bypass data validation.
			 */
			disableDataValidation: {
				value:		__NGN.coalesce(config.disableDataValidation,false),
				enumerable:	false,
				writable:	true
			},
			
			_invalidDataAttributes: {
				value:		[],
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-property-originalConfig'>			/**
</span>			 * @property {Object}
			 * The original config values passed to the constructor.
			 * @readonly
			 */
			originalConfig: {
				value:		__NGN.clone(config),
				enumerable:	false,
				writable:	false
			},
			
<span id='NGN-model-Model-property-fetched'>			/**
</span>			 * @property {Boolean}
			 * Stores whether the object is considered fetched.
			 * @private
			 */
			fetched: {
				value:		false,
				enumerable:	false,
				writable:	true
			},
			
			_isXtn: {
				value: 		config.hasOwnProperty('extend'),
				enumerable:	false,
				writable:	false
			},
			
<span id='NGN-model-Model-property-EXTENDEDMODEL'>			/**
</span>			 * @property {Object}
			 * Automatically generates a model with data management events.
			 * This uses proxies (harmony proxies) to emit events on object
			 * property changes such as get/set/create/delete/etc.
			 * @private
			 */
			EXTENDEDMODEL: {
				enumerable:	false,
				get:		function(){
								return this.extension();
							}
			},
			
			configured: {
				value: 		false,
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-property-changelog'>			/**
</span>			 * @property {Object[]}
			 * An ordered array of changes made to the object data properties.
			 * This should not be changed manually. Instead, use #getChangeLog
			 * and #rollback to manage this list.
			 * @private
			 */
			changelog: {
				value:		[],
				enumerable:	false,
				writable:	true
			},
			
<span id='NGN-model-Model-property-_xref'>			/**
</span>			 * @property {Object}
			 * Contains references to associations.
			 * @private
			 */
			_xref: {
				value:		{},
				enumerable:	false,
				writable:	true
			},
			
			// Holds a reference to the direct proxy
			_proxy: {
				value:		null,
				enumerable:	false,
				writable:	true
			},
			
			initialDataAttributes: {
				value:		[],
				enumerable:	false,
				writable:	true
			},
			
			_nativeValidators: {
				value:		{
								min: function(min,value){
									if (value instanceof Array)
										return value.length &gt;= min;
									if (value instanceof Number)
										return value &gt;= min;
									if (value instanceof String)
										return value.trim().length &gt;= min;
									if (value instanceof Date)
										return value.parse() &gt;= min.parse();
									return false;
								},
								max: function(max,value){
									if (value instanceof Array)
										return value.length &lt;= max;
									if (value instanceof Number)
										return value &lt;= max;
									if (value instanceof String)
										return value.trim().length &lt;= max;
									if (value instanceof Date)
										return value.parse() &lt;= max.parse();
									return false;
								},
								'enum': function(valid,value){
									return valid.indexOf(value) &gt;= 0;
								},
								required: function(field){
									return this.hasOwnProperty(field);
								}
							},
				enumerable:	false,
				writable:	false		
			}
			
		});
		
		if (!this.fields.hasOwnProperty('id')){
			config.fields.id = {
									required: 	true,
									type:		String,
									'default':	config.id || null
								}
		}
		
		var me = this;
		
		// Add fields
		for (var field in this.fields){
			if (['id'].indexOf(field) &lt; 0) {
				if (this[field] !== undefined){
					this.fireWarning(field+' data field defined multiple times. Only the last defintion will be used.');
					delete this[field];
				}
				
				// Create the data field as an object attribute
				Object.defineProperty(this,field,{
					value:		this.fields[field]['default'],
					enumerable:	true,
					writable:	true
				});
				
				// Add field validators
				if (!this.disableDataValidation){
					if (this.fields[field].hasOwnProperty('pattern'))
						this.addValidator(field,this.fields[field].pattern);
					if (this.fields[field].hasOwnProperty('min'))
						this.addValidator(field,function(val){
							return me._nativeValidators.min(me.fields[field],val);
						});
					if (this.fields[field].hasOwnProperty('max'))
						this.addValidator(field,function(val){
							return me._nativeValidators.max(me.fields[field],val);
						});
					if (this.fields[field].hasOwnProperty('enum'))
						this.addValidator(field,function(val){
							return me._nativeValidators['enum'](me.fields[field],val);
						});
					if (this.fields[field].hasOwnProperty('required')){
						if (this.fields[field].required)
							this.addValidator(field,function(val){
								return me._nativeValidators.required(val);
							});
					}
					if (this.fields[field].hasOwnProperty('validate')){
						if (typeof this.fields[field] === 'function')
							this.addValidator(field,function(val){
								return me.fields[field](val);
							});
						else
							this.fireWarning('Invalid custom validation function. The value passed to the validate attribute must be a function.');
					}
				}
			}
		}

		// Add hooks hook, pre, and post
		for (var k in hooks)
			this[k] = hooks[k];

		// Add pre/post events to each method
		this.pre('save',function(next){
			if (!me.disableDataValidation &amp;&amp; !me.allowInvalidSave) {
				if (!me.validate()){
					me.fireError('Invalid data for '+me._invalidDataAttributes.join()+' attribute'+(me._invalidDataAttributes.length&gt;1?'s':''));
					return;
				}	
			}
			me.onBeforeSave();
			next();
		});
		this.post('save',function(next){
			me.onSave();
			next();
		});
		this.pre('destroy',function(next){
			me.onBeforeDestroy();
			next();
		});
		this.post('destroy',function(next){
			me.onDestroy();
			next();
		});
				
		if (me[me.idAttribute])
			me.fetch();

		// Support for global notifications
		if (NGNA){
			if (NGNA.hasOwnProperty('Events')){
				this.on('new',function(model){
					NGNA.dispatch('new',me.type);
				});
			}
		}
		
		// DO NOT CHANGE THIS
		// This is a smart object that returns a proxy if enabled,
		// or a standard object if not enabled.
		return this.EXTENDEDMODEL;
	},
	
<span id='NGN-model-Model-method-pre'>	/**
</span>	 * @method pre
	 * This method will execute **before** the specified method.
	 * For example:
	 * 		var person = new NGN.model.Person();
	 * 		
	 * 		person.pre('save',function(next){
	 * 			...
	 * 			next();
	 * 		});
	 * This method is chainable, so it is possible to add additional
	 * hooks, like:
	 * 		var person = new NGN.model.Person();
	 * 		
	 * 		person.pre('save',function(next){
	 * 			...
	 * 			next();
	 * 		}).pre('save',function(next){
	 * 			...
	 * 			next();
	 * 		});
	 * @chainable
	 */
	
<span id='NGN-model-Model-method-post'>	/**
</span>	 * @method post
	 * This method will execute **after** the specified method.
	 * For example:
	 * 		var person = new NGN.model.Person();
	 * 		
	 * 		person.post('save',function(next){
	 * 			...
	 * 			next();
	 * 		});
	 * This method is chainable, so it is possible to add additional
	 * hooks, like:
	 * 		var person = new NGN.model.Person();
	 * 		
	 * 		person.post('save',function(next){
	 * 			...
	 * 			next();
	 * 		}).post('save',function(next){
	 * 			...
	 * 			next();
	 * 		});
	 * @chainable
	 */
	
<span id='NGN-model-Model-method-hook'>	/**
</span>	 * @method hook
	 * The hook method can be used to provide an arbitrary handler for a specific method.
	 * For example, custom error handling can be managed with `hook`.
	 * 
	 */
	
<span id='NGN-model-Model-method-prepConfig'>	/**
</span>	 * @method
	 * A helper method to prepare configuration. This allows a non-object
	 * to be passed as a single configuration argument, which is automatically
	 * converted to the #id field. For example:
	 * 		var myModel = new NGN.model.Model('someID_123');
	 * The model automatically converts this to an object like:
	 * 		{
	 * 			id: 'someID_123'
	 * 		}
	 * As a result, the expected configuration object is always passed as the only
	 * argument to a constructor.
	 * @protected
	 */
	prepConfig: function(config) {
		if (typeof config !== 'object') {
			config = {
				id: config
			};
		}
		
		return config || {};
	},
	
<span id='NGN-model-Model-method-addValidator'>	/**
</span>	 * @method
	 * Add or update a validation rule for a specific model property.
	 * @param {String} property
	 * The property to test.
	 * @param {Function/String[]/Number[]/Date[]/RegExp/Array} validator
	 * The validation used to test the property value. This should return
	 * `true` when the data is valid and `false` when it is not. 
	 * 
	 * * When this is a _function_, the value is passed to it as an argument.
	 * * When this is a _String_, the value is compared for an exact match (case sensitive)
	 * * When this is a _Number_, the value is compared for equality.
	 * * When this is a _Date_, the value is compared for exact equality.
	 * * When this is a _RegExp_, the value is tested and the results of the RegExp#test are used to validate.
	 * * When this is an _Array_, the value is checked to exist in the array, regardless of data type. This is treated as an `enum`.
	 * * When this is _an array of dates_, the value is compared to each date for equality.
	 */
	addValidator: function(property,validator){
		if (!this.hasOwnProperty(property)){
			this.fireWarning('No validator could be create for '+property.toUpperCase()+'. It is not an attribute of '+this.type.toUpperCase()+'.');
			return;
		}
		switch (typeof validator){
			case 'function':
				this.validators[property] = this.validators[property] || [];
				this.validators[property].push(validator);
				break;
			case 'object':
				if (Array.isArray(validator)){
					this.validators[property] = this.validators[property] || [];
					this.validators[property].push(function(value){
						return validator.indexOf(value) &gt;= 0;
					});
				} else if (validator.test){ // RegExp
					this.validators[property] = this.validators[property] || [];
					this.validators[property].push(function(value){
						return validator.test(value);
					});
				} else
					this.fireWarning('No validator could be created for '+property.toUpperCase()+'. The validator appears to be invalid.');
				break;
			case 'string':
			case 'number':
			case 'date':
				this.validators[property] = this.validators[property] || [];
				this.validators[property].push(function(value){
					return value == validator;
				});
				break;
			default:
				this.fireWarning('No validator could be create for '+property.toUpperCase()+'. The validator appears to be invalid.');
		}
		
	},
	
<span id='NGN-model-Model-method-removeValidator'>	/**
</span>	 * @method
	 * Remove a data validator from the object.
	 * @param {String} attribute
	 * The name of the attribute to remove from the validators.
	 */
	removeValidator: function(attribute){
		if (this.validators.hasOwnProperty(attribute)){
			delete this.validators[attribute];
		}		
	},
	
<span id='NGN-model-Model-method-validate'>	/**
</span>	 * @method
	 * Validate one or all attributes of the data.
	 * @param {String} [attribute=null]
	 * Validate a specific attribute. By default, all attributes are tested.
	 * @private
	 */
	validate: function(attribute){
		if (this.disableDataValidation)
			return undefined;
		
		var _pass = true;
		
		// Single Attribute Validation
		if (attribute){
			if (this.validators.hasOwnProperty(attribute)){
				_pass = this.validationMap[attribute](this[attribute]);
				if (!_pass)
					this._invalidDataAttributes.push(attribute);
				return _pass;
			}
		}
		
		// Validate All Attributes
		for (var rule in this.validators){
			if (this[rule]) {
				if (this.validators.hasOwnProperty(rule)){
					var pass = true;
					for (var i=0; i&lt;this.validators[rule].length; i++){
						pass = this.validators[rule][i](this[rule]);
						if (!pass)
							break;
					}
					if (!pass &amp;&amp; this._invalidDataAttributes.indexOf(rule) &lt; 0)
						this._invalidDataAttributes.push(rule);
					
					if (_pass &amp;&amp; !pass)
						_pass = false;
				}
			}
		}
		return _pass;
	},
	
<span id='NGN-model-Model-method-enableDataValidation'>	/**
</span>	 * @method
	 * Enable data validation if #disableDataValidation is `true`.
	 */
	enableDataValidation: function(){
		this.disableDataValidation = false;
	},
	
<span id='NGN-model-Model-method-disableDataValidation'>	/**
</span>	 * @method
	 * Disable data validation. Sets #disableDataValidation to `true`.
	 */
	disableDataValidation: function(){
		this.disableDataValidation = true;
	},
	
<span id='NGN-model-Model-method-getAssociation'>	/**
</span>	 * @method
	 * Get a model from the known associations. Associations are stored when the #serialize method
	 * encounters a nested NGN.model.Model. #save and #fetch use #serialize.
	 * @param {Number/String}
	 * The reference number or full xref string (i.e. `xref::1`)
	 * @returns {NGN.model.Model}
	 */
	getAssociation: function(ref) {
		if (typeof ref == 'string')
			ref = parseInt(ref.split('::'));
		if ((ref[1]-1 &lt;= 0 || ref[1]-1 &gt; this._ref.length) || ref[0].toString().toLowerCase() == 'xref'){
			this.onNoAssociation(ref);
			return null;
		}
		return this._xref[ref[1]-1];
	},
	
<span id='NGN-model-Model-method-getAssociations'>	/**
</span>	 * @method
	 * Get the association map.
	 * @returns {Object}
	 */
	getAssociations: function() {
		return this._xref;
	},
	
<span id='NGN-model-Model-method-getDataFields'>	/**
</span>	 * @method
	 * Provides an array of data fields associated with the model.
	 * @returns {String[]}
	 */
	getDataFields: function(){
		var list = [];
		for (var field in this.fields)
			list.push(field);
		return list;
	},
	
<span id='NGN-model-Model-method-getDataField'>	/**
</span>	 * @method
	 * Provides specific detail/configuration about a field.
	 * @param {String} fieldname
	 * @returns {Object}
	 */
	getDataField: function(fieldname){
		return this.fields[fieldname];
	},
	
<span id='NGN-model-Model-method-hasDataField'>	/**
</span>	 * @method
	 * Indicates a data field exists.
	 * @param {String} fieldname
	 * @returns {Boolean}
	 */
	hasDataField: function(fieldname){
		return this.fields.hasOwnProperty(fieldname);
	},
	
<span id='NGN-model-Model-method-serialize'>	/**
</span>	 * @method
	 * Creates a JSON data object with no functions. Only uses enumerable attributes of the object by default.
	 * Specific data values can be included/excluded using #enumerableProperties &amp; #nonEnumerableProperties.
	 * 
	 * Any object property that begins with a special character will be ignored by default. Functions &amp; Setters are always
	 * ignored. Getters are evaluated recursively until a simple object type is found or there are no further nested attributes.
	 * 
	 * If a value is an instance of NGN.model.Model (i.e. a nested model or array of models), reference string is returned in the data.
	 * The model itself can be returned using #getXRef.
	 * @param {Object} [obj]
	 * Defaults to this object.
	 * @param {Boolean} [serializeAssociations=false]
	 * When set to `true`, any cross referenced data (NGN.model.Association) will be retrieved
	 * and serialized into JSON objects. Use this when a complete JSON dump is
	 * required.
	 * @returns {Object}
	 * @protected
	 */
	serialize: function(obj,serializeAssociations){
	
		if (obj == true || obj == false){
			serializeAssociations = obj;
			obj = this;
		}
		
		serializeAssociations = __NGN.coalesce(serializeAssociations,false);

		var _obj = obj || this;
		var me = this, struct = {}, rtn = {};
		
		this._ref = {};
		
		for (var key in _obj) {
			
			_obj.nonEnumerableProperties = _obj.nonEnumerableProperties || '';
			if (this.fields.hasOwnProperty(key)) {
				key = key == 'id' ? this.idAttribute : key;
				if ((_obj.hasOwnProperty(key) &amp;&amp; (_obj.nonEnumerableProperties.indexOf(key) &lt; 0 &amp;&amp; /^[a-z0-9 ]$/.test(key.substr(0,1)))) || (_obj[key] !== undefined &amp;&amp; _obj.enumerableProperties.indexOf(key) &gt;= 0)) {
					var dsc = Object.getOwnPropertyDescriptor(_obj,key);
					if (dsc.get){
						try {
							rtn[key] = typeof _obj[key] == 'object' ? _obj[key].serialize(serializeAssociations) : _obj[key];
						} catch(e) {}
					} else if (!dsc.set) {
						switch (typeof dsc.value) {
							case 'function':
								// Support date &amp; regex proxies
								if (dsc.value.name == 'Date'){
									rtn[key] = _obj[key].refs.toJSON();
								} else if (dsc.value.name == 'RegExp'){
									rtn[key] = dsc.value();
								}
								break;
							case 'object':
								// Support array proxies
								if (_obj[key] instanceof Array &amp;&amp; !Array.isArray(_obj[key]))
									_obj[key] = _obj[key].slice(0);
													
								var isXRef = _obj[key] instanceof __NGN.model.data.Association;
											
								if (Array.isArray(_obj[key])){				
									for (var i=0;i&lt;_obj[key].length;i++){
										if (_obj[key][i] instanceof __NGN.model.data.Association){
											if (serializeAssociations)
												_obj[key][i] = _obj[key][i].child.serialize(serializeAssociations);
										}
									}
									if (_obj[key].length &gt; 0)
									rtn[key] = _obj[key];
									break;
								}
	
								if (isXRef){
									if (serializeAssociations)
										rtn[key] = _obj[key].serialize(serializeAssociations);
									else
										rtn[key] = _obj[key];
								} else if (_obj[key]){
									struct = _obj[key].hasOwnProperty('serialize') == true ? _obj[key].serialize(serializeAssociations) : _obj[key];	
									if (Object.keys(struct).length &gt; 0){
										rtn = me.merge(rtn,struct);
									}
								}
								break;
							default:
								rtn[key] = _obj[key];
								break;
						}
					}
				}
			}
		}
		
		return rtn;
	},
	
<span id='NGN-model-Model-method-getChanges'>	/**
</span>	 * @method
	 * Get the changes made to the model. If the model is fetched from a data store, the changes
	 * will include any newly created data attributes, updates, and attribute removals.
	 * @param {Boolean} [serializeAssociations=false]
	 * When set to `true`, any cross referenced data (NGN.model.Association) will be retrieved
	 * and serialized into JSON objects. Use this when a complete JSON dump is
	 * required.
	 * @return {Object}
	 * The object contains up to 3 attributes:
	 * 		{
	 * 			create: {}, // &lt;-- Key/value list of all new data attributes
	 * 			update: {}, // &lt;-- Key/value list of all updated data attributes 
	 * 			destroy:{}  // &lt;-- Key/value list of all removed data attributes
	 * 		}
	 * For _new_ objects, only the `create` key is available.
	 * These keys only exist when changes are made. The entire changelog can be retrieved
	 * with #getChangeLog.
	 */
	getChanges: function(serializeAssociations){
		serializeAssociations = __NGN.coalesce(serializeAssociations,false)
		
		// If it's a new object, everything is new
		if (this.isNew)
			return {
				create: this.serialize(serializeAssociations),
			};
		
		var upd = {}, add = {}, rmv = {};
		for (var i=0; i&lt;this.changelog.length; i++){
			var log = this.changelog[i];
			if (log.type == 'update' &amp;&amp; !add.hasOwnProperty(log.property)){
				upd[log.property] = this[log.property].refs !== undefined ? this[log.property].refs : (this[log.property] instanceof Array ? this[log.property].slice(0) : this[log.property]);
			}
			if (log.type == 'delete' &amp;&amp; rmv.hasOwnProperty(log.property) &amp;&amp; !this.hasOwnProperty(log.property)) {
				rmv[log.property] = this[log.property].refs !== undefined ? this[log.property].refs : (this[log.property] instanceof Array ? this[log.property].slice(0) : this[log.property]);
				if (upd[log.property])
					delete upd[log.property];
				if (add[log.property])
					delete add[log.property];
			} 
			if (log.type == 'create' &amp;&amp; !add.hasOwnProperty(log.property) &amp;&amp; this.hasOwnProperty(log.property) &amp;&amp; this.initialDataAttributes.indexOf(log.property) &lt; 0) {
				add[log.property] = this[log.property].refs !== undefined ? this[log.property].refs : (this[log.property] instanceof Array ? this[log.property].slice(0) : this[log.property]);
				if (upd[log.property])
					delete upd[log.property];
				if (rmv[log.property])
					delete rmv[log.property];
			}
		}
		
		var rtn = {};
		if (Object.keys(upd).length &gt; 0)
			rtn.update = upd;
		if (Object.keys(add).length &gt; 0)
			rtn.create = add;
		if (Object.keys(upd).length &gt; 0)
			rtn.remove = rmv;	
		return rtn;
	},
	
<span id='NGN-model-Model-method-fetch'>	/**
</span>	 * @method
	 * Populate the model with data for an existing object.
	 * @private
	 * @uses serialize
	 */
	fetch: function(id){
		if (this.CRUD){		
			this.onBeforeFetch();
			
			var me = this;
			this.CRUD.read(this,function(result){	
				if (result){
					var data = me.CRUD.processReverseDataMap(result,me.type);
					for (var attr in data){
						if (me.nonEnumerableProperties.indexOf(attr) &lt; 0)
							me[attr] = data[attr];
					}
					if (me.idAttribute)
						me[me.idAttribute] = me.id;
					me.onFetch();
				} else
					me.onNoResult();
			});
		} else
			this.fireWarning(this.type.toString().toUpperCase()+' cannot be fetched because no persistence/CRUD object is associated with the NGN.model.');	
	},
	
<span id='NGN-model-Model-method-save'>	/**
</span>	 * @method
	 * Persist the data. This only works when an #CRUD is specified.
	 * @param {Function} callback
	 * @uses serialize
	 */
	save: function(callback) {
		if (this.CRUD){
			var me = this, data = this.serialize();
			callback = callback || __NGN.noop;

			if (this.id){
				var allSaves = [];
				allSaves.push(this.CRUD.update(this));
				for (var ref in this._refs){
					if (this._refs.hasOwnProperty(ref)){
						if (this._refs[ref].modified || !this._refs[ref].id)
							allSaves.push(this._refs[ref].save);
					}
				}
				require('async').parallel(allSaves,function(err,results){
					callback(arguments);
					me.onSave();
				});
			} else {
				this.CRUD.create(this,function(){
					callback(arguments);
					me.onSave();
				});
			}
		} else
			this.fireWarning(this.type.toString().toUpperCase()+' cannot be saved because no persistence/CRUD object is associated with the NGN.model.');
	},
	
<span id='NGN-model-Model-method-destroy'>	/**
</span>	 * @method
	 * Stop persisting the object (i.e. delete it from the datastore). This only works with #CRUD enabled and an #id specified.
	 */
	destroy: function(){
		if (this.isNew){
			this.fireWarning(model.type+' cannot be removed because it is new (i.e. not saved yet).');
			return;
		}
		console.log('TODO: Detroy Method'.red);
		return;
	},
	
<span id='NGN-model-Model-method-getChangeLog'>	/**
</span>	 * @method
	 * Returns an array of changes made to the object.
	 * Each element of the array is a change object, which is 
	 * a simple JSON object. The syntax is:
	 * 	{
	 * 		type: 'create|update|delete',
	 * 		oldValue: Object, // Only exists for update and delete.
	 * 		value: Object // Only exists for create and update
	 * 	}
	 * @returns {Array}
	 */
	getChangeLog: function(){
		if (!__NGN.OBJECT_PROXY_SUPPORT)
			this.fireWarning('Model '+this.type+'#getChangeLog cannot run because change management is not enabled. To enable, launch the app as:\n'+('node '+'--harmony '.bold+process.mainModule.filename).yellow+'\n');
		
		return this.changelog;
	},
	
<span id='NGN-model-Model-method-rollback'>	/**
</span>	 * @method
	 * Simple &quot;undo&quot;. It rolls back the changelog and
	 * reverses the changes made in each log entry.
	 * This method is only available when using proxies.
	 * @param {Number} [changes=1]
	 * The number of changes to rollback. A value of `-1` will rollback all changes.
	 */
	rollback: function(changes){
		if (!__NGN.OBJECT_PROXY_SUPPORT){
			this.fireWarning('Model '+this.type+'#rollback cannot execute because change management is not enabled. To enable, launch the app as:\n'+('node '+'--harmony '.bold+process.mainModule.filename).yellow+'\n');
			return;
		}
		changes = changes || 1;
		changes = changes &lt; 1 ? this.changelog.length : changes;

		// Loop through the changelog and reverse each change sequentially.
		for (var i=0; i&lt;changes; i++){
			var delta = this.changelog[this.changelog.length-1];
			switch(delta.type.trim().toLowerCase()){
				case 'create':
					delete this._proxy['___rollback::'+delta.property];
					this.changelog.pop();
					this.onRollback(delta);
					break;
				case 'update':		
					this._proxy['___rollback::'+delta.property] = delta.oldValue;
					this.changelog.pop();
					this.onRollback(delta);
					break;
				case 'delete':
					this._proxy['___rollback::'+delta.property] = delta.oldValue;
					this.changelog.pop();
					this.onRollback(delta);
					break;
				case 'start':
					break;
				default:
					this.fireWarning('Rollback Failed: '+delta.type+' not a recognized change type.');
					break;
			}
		}
	},
	
<span id='NGN-model-Model-method-extension'>	/**
</span>	 * @model
	 * 
	 * @private
	 */
	extension: function() {
		
		this.configured = true;
		
		if (!__NGN.OBJECT_PROXY_SUPPORT){
			//this.fireWarning('Model '+this.type+' does not have change management support. To enable, launch the app as:\n'+('node '+'--harmony '.bold+process.mainModule.filename).yellow+'\n');
			delete this.rollback;
			delete this.changelog;
			delete this.getDiff;
			delete this.onBeforeChange;
			delete this.onChange;
			delete this.onRollback;
		}
		
		// Add virtual getters
		for (var v in this.virtuals){
			if (this.virtuals.hasOwnProperty(v)){	
				if (this[v] !== undefined){
					this.fireWarning('Model attribute '+v.trim().toUpperCase()+' overwritten by virtual data attribute.');
					delete this[v];
				}
				Object.defineProperty(this,v,{
					enumerable:	true,
					get:		this.virtuals[v]
				});
			}
		}
		
		// If this is an extension, return the model without applying the proxy
		// This supports creation of an inherited object with a proxy.
		if (this._isXtn || !__NGN.OBJECT_PROXY_SUPPORT)
			return this;
		
		var me = this;
		
		Proxy = Proxy || function(){ return me; };

		this._proxy = NGN.model.data.Monitor(this);
		
		return this._proxy;
	},
	
<span id='NGN-model-Model-method-beforeDataChange'>	/**
</span>	 * @method
	 * Executed before a data attribute is created, modified, or removed. This is an empty method that should be overridden.
	 * Processing will abort when this method returns `false`.
	 * @param {Object} changeObject
	 * @returns {Boolean}
	 * The return value is used to determine whether processing continues or halts.
	 */
	beforeDataChange: function(changeObject){
		return true;
	},
	
<span id='NGN-model-Model-method-beforeSave'>	/**
</span>	 * @method
	 * Executed before a #save. This is an empty method that should be overridden.
	 * Processing will abort when this method returns `false`.
	 * @param {Object} changeObject
	 * @returns {Boolean}
	 * The return value is used to determine whether processing continues or halts.
	 */
	beforeSave: function(changeObject){
		return true;
	},
	
<span id='NGN-model-Model-method-beforeDestroy'>	/**
</span>	 * @method
	 * Executed before a #destroy.
	 * This is an empty method that should be overridden.
	 * Processing will abort when this method returns `false`.
	 * @param {Object} changeObject
	 * @returns {Boolean}
	 * The return value is used to determine whether processing continues or halts.
	 */
	beforeDestroy: function(changeObject){
		return true;
	},
	
<span id='NGN-model-Model-event-beforeChange'>	/**
</span>	 * @event beforeChange
	 * Fired before a change is completed.
	 * Provides the following change object to the callback:
	 * 	{
	 * 		type: 'create|update|delete',
	 * 		oldValue: Object, // Only exists for update and delete.
	 * 		value: Object // Only exists for create and update
	 * 	}
	 */
	onBeforeChange: function(change) {
		change = change || null;
		this.emit('beforeChange',change);
		if (change !== null)
			this.emit('beforeChange'+__$.capitalize(change.property),change);
		return true;
	},
	
<span id='NGN-model-Model-event-change'>	/**
</span>	 * @event change
	 * Fired after the change is complete.
	 * Provides the following change object to the callback:
	 * 	{
	 * 		type: 'create|update|delete',
	 * 		oldValue: Object, // Only exists for update and delete.
	 * 		value: Object // Only exists for create and update
	 * 	}
	 */
	onChange: function(change) {
		change = change || null;
		this._modified = true;
		this.changelog.push(change);
		this.emit('change',change);
		if (change !== null)
			this.emit('change'+__$.capitalize(change.property),change);
	},
	
<span id='NGN-model-Model-event-beforeSave'>	/**
</span>	 * @event beforeSave
	 * Fired before the model attempts to persist data.
	 */
	onBeforeSave: function(){
		this.emit('beforeSave',this);
	},
	
<span id='NGN-model-Model-event-save'>	/**
</span>	 * @event save
	 * Fired when the model attempts to persist data to a datasource.
	 */
	onSave: function(){
		this._modified = false;
		this._modifiedAttributes = [];
		this.isNew = false;
		this.emit('save',this);
	},
	
<span id='NGN-model-Model-event-beforeFetch'>	/**
</span>	 * @event beforeFetch
	 * Fired before the model attempts to populates its data from a datasource.
	 */
	onBeforeFetch: function(){
		this.emit('beforeFetch',this);
	},
	
<span id='NGN-model-Model-event-fetch'>	/**
</span>	 * @event fetch
	 * Fired when the model attempts to populate its data from a datasource.
	 */
	onFetch: function(){
		if (!this.fetched){
			this.isNew = (this.id == null);
			this.fetched = true;
			this.emit('fetch',this);
		}
	},
	
<span id='NGN-model-Model-event-beforeRemove'>	/**
</span>	 * @event beforeRemove
	 * Fired before the model attempts to remove its data from a datasource.
	 */
	onBeforeDestroy: function(){
		this.emit('beforeRemove',this);
	},
	
<span id='NGN-model-Model-event-destroy'>	/**
</span>	 * @event destroy
	 * Fired when the model has removed its data from a datasource.
	 */
	onDestroy: function(){
		this.emit('remove',this);
		delete this;
	},
	
<span id='NGN-model-Model-event-noData'>	/**
</span>	 * @event noData
	 * Fired when a #fetch returns no records.
	 */
	onNoData: function(){
		this.emit('noData')
	},
	
<span id='NGN-model-Model-event-rollback'>	/**
</span>	 * @event rollback
	 * Fired when a rollback occurs.
	 * @param {Object} delta
	 */
	onRollback: function(delta){
		this.emit('rollback',delta);
	}
	
});

module.exports = Class;

</pre>
</body>
</html>
